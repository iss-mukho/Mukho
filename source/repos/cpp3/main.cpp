/*
... iss Crew
... Made By Mukho
... 2020-06-21 SUN
... Practice for C++
*/

#include <iostream>
using namespace std;

int main()
{
	return 0;
}

/* 연산자 오버로딩(Operator Overloading)
	같은 일을 처리하는 함수를 매개변수의 형식을 조금씩 달리하여 하나의 이름으로 작성할 수 있게 하는 것.
	연산자 함수 : operator오버로딩할연산자(매개변수목록)
					ex) 두 지점의 중간 지점 좌표 구하기
							Position Position::operator-(const Position& other)
							{
								return Position( (x_ + other.x_) / 2, (y_ + other.y_) / 2);
							}

		연산자 함수를 정의하는 방법
			- 클래스의 멤버 함수로 정의 :위에 적은거임
			- 전역 변수로 정의 : (private 멤버에 대한 접근을 위해 friend 함수를 사용할 수 있다.)
								 Position operator-(const Position& pos1, const Position& pos2)
								 {
									return Position((pos1.x_ + pos2.x_)/2, (pos1.y_ + pos2.y_)/2);
								 } 
		오버로딩의 제약 사항
			- 전혀 새로운 연산자를 정의할 수 없음
			- 기본 타입을 다루는 연산자의 의미는 재정의할 수 없음. 따라서 오버로딩된 연산자의 피연산자 중 하나는 반드시 사용자 정의 타입이어야 함
			- 오버로딩된 연산자는 기본 타입을 다루는 경우에 적용되는 피연산자의 수, 우선순위 및 그룹화를 준수햐해야 함
			- 오버로딩된 연산자는 디폴트 인수를 사용할 수 없음
		멤버 함수로만 오버로딩할 수 있는 연산자 : =, (), [], ->
*/
/* OOP 캡슐화
	friend : private 멤버는 해당 객체의 public 멤버 함수를 통해서만 접근 가능하지만, 경우에 따라 해당 객체의 멤버 함수가 아닌 함수도 private 멤버에 접근해야만 할 경우가 있고, 그 때마다 public 멤버 함수를 작성하는 것은 비효율적
			 friend는 지정한 대상에 한해 해당 객체의 모든 멤버에 접근할 수 있는 권한을 부여해 줌.
			 전역함수, 클래스, 멤버함수 세 가지 형태로 사용 가능함.
				friend 클래스이름 함수이름(매개변수목록);
				- 클래스 선언부에 원형이 포함되지만, 클래스의 멤버 함수는 아니다. 멤버 함수와 같은 접근 권한을 가지게 됨
			 클래스에 대해 이항 연산자를 오버로딩할 때 friend의 필요성이 자주 발생함.
				- 멤버 함수란 왼쪽 피연산자인 객체가 호출하는 형태가 되어야 하기 때문. 피연산자의 순서를 바꾸어 실행하면 오류가 발생할 것임.
					기존의 연산자와 더불어 매개변수의 순서가 다른 또 하나의 연산자를 friend를 이용한 전역 함수로 작성하자.
						    ...
							Rect operator*(double mul) const;
							friend Rect operator*(double mul, const Rect& origin); // 프렌드 함수
							};
							...
							Rect Rect::operator*(double mul) const { return Rect(height_ * mul, width_ * mul); }
							Rect operator*(double mul, const Rect& origin) { return origin * mul; }
	friend class : 만약 두 클래스가 기능상으로 서로 밀접한 관계에 있고, 상대방의 private 멤버에 접근해야만 한다면 class를 friend로 선언하자.
				   해당 클래스의 모든 멤버 함수가 특정 클래스의 friend인 클래스
				   friend class 클래스이름; // 타 클래스의 선언부에 선언.
	friend member function : 해당 클래스의 특정 멤버 함수만을 프렌드로 지정하는 것.
							 정보 은닉(data hiding), 캡슐화(encapsulation) 개념에 더욱 가깝게 구현할 수 있음.
								friend void Display::ShowDiagonal(const Rect& target); // 프렌드 멤버 함수 선언
	전방 선언(forward declaration) : 두 클래스의 선언 내에서 서로를 참조하고 있는 상황을 순환 참조(circular reference)라고 함.
									 이를 피하기 위해 한 클래스를 다른 클래스의 앞에 미리 선언하는 전방 선언을 사용해야 함. class 클래스이름
										class Rect;          // 전방 선언
										class Display {...}; // Display 클래스 선언
										class Rect {...};    // Rect 클래스 선언
	정적 멤버 변수(static member variable) : 클래스에는 속하지만, 객체 별로 할당되지 않고 클래스의 모든 객체가 공유하는 멤버
											 멤버 변수가 정적으로 선언되면, 해당 클래스의 모든 객체에 대해 하나의 데이터만이 유지 관리된다.
											 클래스 영역에서 선언되지만, 정의는 파일 영역에서 수행됨. 외부 연결을 가지므로 여러 파일에서 접근할 수 있다.
											 클래스의 멤버 함수나 friend만이 접근할 수 있지만, 외부에서도 접근 가능하게 하려면 public 영역에 선언하자.
	정적 멤버 함수(static member function) : 해당 클래스의 객체를 생성하지 않고도, 클래스 이름만으로 호출할 수 있음.
												 객체이름.멤버함수이름();   // 일반 멤버 함수의 호출
												 클래스이름.멤버함수이름(); // 정적 멤버 함수의 호출
											 객체를 생성하지 않으므로 this 포인터를 가지지 않음.
											 특정 객체와 결합하지 않으므로 정적 멤버 변수밖에 사용할 수 없음.
											 	 static int person_count_;            // 정적 멤버 변수의 선언
												 static int person_count();           // 정적 멤버 함수의 선언 -> 정적 멤버 변수를 사용하기 위한 정적 멤버 함수
	상수 멤버 변수(constant member variable) : 한 번 초기화하면, 그 값을 변경할 수 없는 멤버 변수.
											   클래스 전체에 걸쳐 사용되는 중요한 상수는 상수 멤버 변수로 정의하여 사용하는 것이 좋음. // const 타입 멤버변수이름;
	상수 멤버 함수(constant member function) : 호출한 객체의 데이터를 변경할 수 없는 멤버 함수. // 함수의원형 const;
													- 호출한 객체의 데이터를 단순히 읽기만 하는 멤버 함수는 상수 멤버 함수로 정의하는 것이 정보 보호 측면에서도 좋다.
*/
/* OOP 상속성
	상속(inheritance) : 사용자에게 높은 수준의 코드 재활용성을 제공하며, 클래스 간의 계층적 관계를 구성함으로써 다형성의 문법적 토대를 마련함
	클래스 상속 : 기존에 정의되어 있는 클래스의 모든 멤버 변수와 멤버 함수를 물려받아 새로운 클래스를 작성하는 것.
		base/parent/super class ---- derived/child/sub class
				   기존에 작성된 클래스를 재활용할 수 있으며, 공통적인 부분은 기초 클래스에 미리 작성하여, 파생 클래스에서 중복되는 부분을 제거할 수 있음.
		class 파생클래스이름 : 접근제어지시자(private, public, protected) 기초클래스이름[, 접근제어지시자 기초클래스이름. ...]
			- 파생 클래스의 접근 제어 권한은 private가 default 값이다. 단일 상속[다중 상속]
			- 파생 클래스에는 반드시 자신만의 생성자를 작성해야 함.
			- 기초 클래스의 접근할 수 있는 모든 멤버 변수들이 저장됨.
			- 기초 클래스의 접근할 수 있는 모든 멤버 함수를 사용할 수 있음.
			- 필요한 만큼 멤버를 추가할 수 있음.
			- 기초 생성자의 생성자를 사용해야만 기초 클래스의 private 멤버를 초기화할 수 있다.
	오버라이딩(overriding) : 이미 정의된 함수를 무시하고, 같은 이름의 함수를 새롭게 정의하는 것.
	멤버 함수 오버라이딩 : 함수의 원형은 기존 멤버 함수의 원형과 같지만, 멤버 함수의 동작만 재정의
		파생 클래스에서 직접 : ㅇㅅㅇ.. 범위 지정 연산자(::)를 사용하면 파생 클래스에서 기초 클래스의 원래 멤버 함수를 호출할 수도 있다.
							   단, 포인터 변수를 사용할 때 예상치 못한 결과를 반환할 수도 있다. 고로 문제를 해결하려면 가상 함수를 이용하자.
		가상 함수를 이용 : virtual 함수원형;
	다중 상속의 문제점 : 여러개의 기초 클래스가 가진 멤버를 모두 상속받을 수 있다는 점에서 매우 강력한 상속 방법이지만
						 - 상속받은 여러 기초 클래스에 같은 이름의 멤버가 존재할 가능성이 있음
						 - 하나의 클래스를 간접적으로 두 번 이상 상속받을 가능성이 있음
						 - 가상 클래스가 아닌 기초 클래스를 다중 상속하면 기초 클래스 타입의 포인터로 파생 클래스를 가리킬 수 없음
						 -> 다중 상속은 프로그래밍을 복잡하게 만들 수 있으며, 그에 비해 싱용성은 그다지 높지 않으므로 될 수 있으면 사용을 자제하자.
*/
/* OOP 다형성
	가상 함수(virtual function) : 파생 클래스에서 재정의할 것으로 기대하는 멤버 함수. 자신을 호출하는 객체의 동적 타입에 따라 실제 호출할 함수가 결정됨.
								  기초 클래스에서 virtual 키워드를 사용해 가상 함수를 선언하면, 파생 클래스에서 재정의된 멤버 함수도 자동으로 가상 함수가 됨.
	동적 바인딩(dynamic binding) : C++ 컴파일러는 함수를 호출할 때, 어느 블록에 있는 함수를 호출해야 하고, 해당 함수가 저장된 정확한 메모리 위치까지도 알아야 함.
								   함수를 호출하는 코드에서 어느 블록에 있는 함수를 실행하라는 의미로 해석하는 것 - 바인딩. C++에서는 함수가 오버로딩될 수 있으므로 이 작업이 조금 복잡해짐.
								   대부분 함수를 호출하는 코드(가상 함수가 아닌 멤버 함수)는 컴파일 타임에 고정된 메모리 주소로 변환됨.(정적 바인딩_static binding or 초기 바인딩_early binding)
								   
								   가상 함수는 프로그램이 실행될 때 객체를 결정하므로, 컴파일 타임에 해당 객체를 특정할 수 없어 가상 함수의 호출은 컴파일러가 어떤 함수를 호출해야 하는지 미리 알 수 없다.
								   따라서 가상 함수의 경우에는 런 타임에 올바른 함수가 실행될 수 있도록 해야 한다. -> 동적 바인딩 or 지연 바인딩_late binding)

								   가상 함수도 결합하는 타입이 분명할 때에는 일반 함수와 같이 정적 바인딩을 함. 이러한 가상 함수는 기초 클래스 타입의 포인터나 참조를 통하여 호출될 때만 동적 바인딩을 하게 됨.
	가상 함수 테이블(virtual function table, vtbl) : 컴파일러가 가상 함수를 다루는 가장 일반적인 방식.
													 C++ 컴파일러는 각각의 객체마다 가상 함수 테이블을 가리키는 포인터를 저장하기 위한 숨겨진 멤버를 하나씩 추가하고, 가상 함수를 단 하나라도 가지는 클래스에 대해서 가상 함수 테이블을 작성함.
													 작성된 가상 함수 테이블에는 해당 클래스의 객체들을 위해 선언된 가상 함수들의 주소가 저장되게 됨.
													 가상 함수를 호출하면, C++ 프로그램은 가상 함수 테이블에 접근하여 자신이 필요한 함수의 주소를 찾아 호출하게 됨.

													 가상 함수를 사용하면 함수의 호출 과정이 복잡해져 메모리와 실행 속도 측면에서 약간의 부담을 가지게 됨.
													 따라서 C++에서 기본 바인딩은 정적 바인딩이며, 필요한 경우에만 가상 함수로 선언하도록 함. // 파생클래스가 재정의 할 가능성이 있으면 가상 함수로 선언하자.
	가상 소멸자 : C++에서 기초 클래스의 소멸자는 반드시 가상으로 선언해야 한다.
					Person *chaewon = new Student;
					...
					delete charwon;
					-> 위의 예제에서 Person 클래스는 Student 클래스의 기초 클래스이므로, hong이라는 Student 객체가 동적으로 할당됨
					   하지만 마지막 구문의 delete 키워드는 ~Student() 소멸자를 호출하지 않고, ~Person() 소멸자를 호출할 것
					   그러므로 Student 객체에 동적으로 할당된 메모리는 정상적으로 해제되지 않을 것
					   하지만 Person 클래스의 소멸자를 가상으로 선언한다면, 위의 구문은 정상적으로 ~Student() 소멸자를 호출할 것

	추상 클래스
		순수 가상 함수(Pure Virtual Function) : 파생 클래스에서 반드시 재정의해야 하는 멤버 함수.
												일반적으로 함수의 동작을 정의하는 본체를 가지고 있지 않으므로, 파생 클래스에서 재정의하지 않으면 사용할 수 없다.

												virtual 멤버함수의원형 = 0; // 함수만 있고 본체가 없다는 의미.
		추상 클래스(Abstract Class) : 하나 이상의 순수 가상 함수를 포함하는 클래스
									  이러한 추상 클래스는 객체 지향 프로그래밍에서 중요한 특징인 다형성을 가진 함수의 집합을 정의할 수 있게 해줌.
									  - 반드시 사용되어야 하는 멤버 함수를 추상 클래스에 순수 가상 함수로 선언해 놓으면, 이 클래스로부터 파생된 모든 클래스에서는 이 가상 함수를 반드시 재정의해야 함
									  - 동작이 정의되지 않은 순수 가상 함수를 포함하고 있으므로, 인스턴스를 생성할 수 없음.
									  - 추상 클래스는 먼저 상속을 통해 파생클래스를 만들고, 만든 파생 클래스에서 순수 가상 함수를 모두 오버라이딩하고 나서야 비로소 파생 클래스의 인스턴스를 생성할 수 있게 됨.
										하지만 추상 클래스 타입의 포인터와 참조는 바로 사용할 수 있다
		
			class Animal
			{
			public:
			    virtual ~Animal() {}  // 가상 소멸자의 선언
				virtual void Cry()=0; // 순수 가상 함수의 선언
			};
			class Dog : public Animal
			{
			public:
				virtual void Cry() { cout << "멍멍!!" << endl; }
			};
			class Cat : public Animal
			{
			public:
				virtual void Cry() { cout << "야옹야옹!!" << endl; }
			};
			
			int main(void)
			{
			    Dog my_dog;
			    my_dog.Cry();
			    Cat my_cat;
			    my_cat.Cry();
			    return 0;
			}
			-> 추상 클래스인 Animal 클래스는 순수 가상 함수인 Cry() 멤버 함수를 가지고 있음.
			   Animal 클래스를 상속받는 파생 클래스인 Dog 클래스와 Cat 클래스는 Cry() 함수를 오버라이딩해야만 인스턴스를 생성할 수 있다.

		추상 클래스의 용도 제한 : C++에서 추상 클래스는 다음과 같은 용도로는 사용할 수 없음.
			- 변수 또는 멤버 변수
			- 함수의 전달되는 인수 타입
			- 함수의 반환 타입
			- 명시적 타입 변환의 타입
*/									
/* Template
	일반화 프로그래밍(Generic Programming) : C++이 가지는 프로그래밍 언어로서의 특징중 하나. 데이터를 중시하는 객체 지향 프로그래밍과는 달리 프로그램의 알고리즘에 중점을 둠.
	Template : 매개변수의 타입에 따라 함수나 클래스를 생성하는 메커니즘.
			   타입이 매개변수에 의해 표현되므로, 매개변수화 타입(parameterized type)이라고도 불림
			   타입마다 별도의 함수나 클래스를 만들지 않고, 여러 타입에서 동작할 수 있는 단 하나의 함수나 클래스를 작성하는 것이 가능.

	함수 템플릿 : 함수의 일반화된 선언
				  같은 알고리즘을 기반으로 하면서, 서로 다른 타입에서 동작하는 함수를 한 번에 정의할 수 있음
				  임의의 타입으로 작성된 함수에 특정 타입을 매개변수로 전달하면, C++ 컴파일러는 해당 타입에 맞는 함수를 생성해 줌.

						template <typename 타입이름> // typename == class
						함수의 원형{
							함수의 본체
						}

						template <typename T>
						void Swap(T& a, T& b)
						{
							T temp;
							temp = a;
							a = b;
							b = temp;
						}
	함수 템플릿의 인스턴스화 : 함수 템플릿이 각각의 타입에 대해 처음으로 호출될 때, C++ 컴파일러는 해당 타입의 인스턴스를 생성함
							   이렇게 생성된 인스턴스는 해당 타입에 대해 특수화된 템플릿 함수이며, 함수 템플릿에 해당 타입이 사용될 때마다 호출됨.
	명시적 특수화(Explicit Specialization) : C++의 함수 템플릿은 특정 타입에 대한 명시적 특수화를 제공하여, 해당 타입에 대해 특별한 동작을 정의할 수 있게 해줌.
											 컴파일러는 호출된 함수에 정확히 대응하는 특수화된 정의를 발견하면, 더는 템플릿을 찾지 않고 해당 정의를 사용함.

											 // 함수 템플릿 원형
											 template <typename T> void Swap(T& a, T& b);

											 // double형을 위한 명시적 특수화
											 template <> void Swap<double>(double&, double&) { ... };
	클래스 템플릿 : 클래스의 일반화된 선언. 타입에 따라 다르게 동작하는 클래스 집합을 만들 수 있음.
					클래스 템플릿에 전달되는 템플릿 인수(template argument)에 따라 별도의 클래스를 만들 수 있게 되며, 템플릿 인수는 타입이거나 명시된 타입의 상숫값일 수 있음.
						template <typename 타입이름>
						class 클래스템플릿이름
						{
						    // 클래스 멤버의 선언
						}

						template <typename T>
						class Data
						{
						private:
							T data_;
						public:
							Data(T dt);
							data(T dt);
							T get_data();
						};
					중첩 클래스 템플릿(nested class template) : 클래스나 클래스 템플릿 내에 또 다른 템플릿을 중첩하여 정의할 수 있음.(멤버 템플릿)
																멤버 템플릿 중에서도 클래스 템플릿을 중첩 클래스 템플릿이라고 함.
																중첩 클래스 템플릿은 바깥쪽 클래스의 범위 내에서 클래스 템플릿으로 선언되며, 정의는 바깥쪽 클래스의 범위 내에서뿐만 아니라 범위 밖에서도 가능.
																	template <typename T>
																	template <typename U>
																	X<T>::Y<U>::멤버함수이름()
																	{
																	    ...
																	}
																위의 예제처럼 바깥쪽 클래스인 X의 외부에 중첩 클래스 템플릿인 Y를 정의하면, 클래스 템플릿의 템플릿 인수와 멤버 템플릿의 템플릿 인수가 둘 다 앞에 명시되어야 한다.

					클래스 템플릿의 특징
						- 하나 이상의 템플릿 인수를 가지는 클래스 템플릿을 선언할 수 있음
							template <typename T, int i>
						- 클래스 템플릿에 디폴트 템플릿 인수를 명시할 수 있음
							template <typename T = int, int i>
						- 클래스 템플릿을 기초 클래스로 하여상속할 수 있음
							template <typename Type>
							class Y : public X <Type>
	명시적 특수화(Explicit Specialization)
		template <> class Data<double> // double형에 대한 명시적 특수화
		{
		private:
		    double data_;
		public:
		    Data(double dt) { data_ = dt; } // 생성자
			data(double dt) { data_ = dt; }
			double get_data()
			{
			    cout << "double형 데이터를 출력합니다!" << endl;
				return data_;
			}
		};
							
	부분 특수화(Partial Specialization) : 템플릿 인수가 두 개 이상이고, 그중 일부에 대해서만 특수화를 해야 할 때
		- 부분 특수화 방법은 먼저 template 키워드 다음에 나오는 꺾쇠괄호(<>)에 특수화하지 않는 타입의 템플릿 인수를 명시하고, 다음에 나오는 꺾쇠괄호(<>)에 특수화하는 타입을 명시하면 됨.
			 template <typename T1> class X<T1, double> { ... };
	
	스마트 포인터(Smart Pointer) : 포인터처럼 동작하는 클래스 템플릿으로, 사용이 끝난 메모리를 자동으로 해제해 줌. Memory Leak으로부터 프로그램의 안전성을 보장해줌.
								   new 키워드를 통해 기본 포인터(raw pointer)가 실제 메모리를 가리키도록 초기화한 후에, 기본 포인터를 스마트 포인터에 대입하여 사용. 정의된 스마트 포인터의 수명이 다하면, 소멸자는 delete 키워드를 사용하여 할당된 메모리를 자동으로 해제함.
								   new 키워드가 반환하는 주소값을 스마트 포인터에 대입하면, 따로 메모리를 해제할 필요가 없어짐.

								   memory 헤더 파일에 정의된 스마트 포인터의 종류
								   - unique_ptr : 하나의 스마트 포인터만이 특정 객체를 소유할 수 있도록, 객체에 소유권 개념을 도입한 스마트 포인터.
												  스마트 포인터는 해당 객체의 소유권을 가지고 있을 때만, 소멸자가 해당 객체를 삭제할 수 있음
												  unique_ptr 인스턴스는 move() 멤버 함수를 통해 소유권을 이전할 수는 있지만, 복사할 수는 없음
												  소유권이 이전되면, 이전 unique_ptr 인스턴스는 더는 해당 객체를 소유하지 않게 재설정됨
														unique_ptr<int> ptr01(new int(5)); // int형 unique_ptr인 ptr01을 선언하고 초기화함.
														auto ptr02 = move(ptr01);          // ptr01에서 ptr02로 소유권을 이전함.
														// unique_ptr<int> ptr03 = ptr01;  // 대입 연산자를 이용한 복사는 오류를 발생시킴. 
														ptr02.reset();                     // ptr02가 가리키고 있는 메모리 영역을 삭제함.
														ptr01.reset();                     // ptr01가 가리키고 있는 메모리 영역을 삭제함.
												  make_unique() 함수는 전달받은 인수를 사용해 지정된 타입의 객체를 생성하고, 생성된 객체를 가리키는 unique_ptr을 반환함
												  이 함수를 사용하면, 예외 발생에 대해 안전하게 대처할 수 있음
								   - shared_ptr : 하나의 특정 객체를 참조하는 스마트 포인터가 총 몇 개인지를 참조하는 스마트 포인터
												  참조하고 있는 스마트 포인터의 개수 = 참조 횟수(reference count)
												  참조 횟수는 특정 객체에 새로운 shared_ptr이 추가될 때마다 1씩 증가하며, 수명이 다할 때마다 1씩 감소함
												  따라서 마지막 shared_ptr의 수명이 다하여, 참조 횟수가 0이 되면 delete 키워드를 사용하여 메모리를 자동으로 해제함
														shared_ptr<int> ptr01(new int(5)); // int형 shared_ptr인 ptr01을 선언하고 초기화함.
														cout << ptr01.use_count() << endl; // 1
														auto ptr02(ptr01);                 // 복사 생성자를 이용한 초기화
														cout << ptr01.use_count() << endl; // 2
														auto ptr03 = ptr01;                // 대입을 통한 초기화
														cout << ptr01.use_count() << endl; // 3  
												  use_count() 멤버 함수는 shared_ptr 객체가 현재 가리키고 있는 리소스를 참조 중인 소유자의 수를 반환
												  make_shared() 함수를 사용하면 shared_ptr 인스턴스를 안전하게 생성할 수 있음
												  make_shared() 함수는 전달받은 인수를 사용해 지정된 타입의 객체를 생성하고, 생성된 객체를 가리키는 shared_ptr을 반환함
												  이 함수를 사용하면, 예외 발생에 대해 안전하게 대처할 수 있음
								   - weak_ptr : 하나 이상의 shared_ptr 인스턴스가 소유하는 객체에 대한 접근을 제공하지만, 소유자의 수에는 포함되지 않는 스마트 포인터
												weak_ptr은 바로 shared_ptr 인스턴스 사이의 순환 참조를 제거하기 위해서 사용됨
*/
/* 반복자
	STL(Standard Template Library) : 알고리즘을 일반화한 표현을 제공하여 데이터의 추상화와 코드를 재활용할 수 있게 함.
		- 컨테이너(container) : 같은 타입의 여러 객체를 저장하는 일종의 집합
		- 알고리즘(algorithm)
		- 반복자(iterator) : STL 컨테이너에 저장된 요소를 반복적으로 순회하여, 각각의 요소에 대한 접근을 제공하는 객체
							 컨테이너의 구조나 요소의 타입과는 상관없이 컨테이너에 저장된 데이터를 순회하는 과정을 일반화한 표현
							 템플릿이 타입과 상관없이 알고리즘을 표현할 수 있게 해준다면, 반복자는 컨테이너와 상관없이 알고리즘을 표현할 수 있게 해주는 것
							 반복자가 가져야 할 요구 사항과 정의되어야 할 연산자_이 요구사 사항을 모두 갖춰야만 STL 알고리즘에서 반복자로 사용될 수 있음.
								- 가리키는 요소의 값에 접근할 수 있어야 함.(참조 연산자(*)가 정의되어야 함)
								- 반복자 사이의 대입 연산, 비교 연산이 가능해야 함.(대입, 관계 연산자가 정의되어야 함)
								- 가리키는 요소의 주변 요소로 이동할 수 있어야 함.(증가 연산자(++)가 정의되어야 함)
							 
							 반복자의 종류
								- 입력 반복자(input iterator) : 가장 단순한 형태의 반복자, 컨테이너로부터 값을 읽는 데 사용(읽기 전용)
																증가 연산자를 사용해 순방향으로만 이동 가능.
																참조 연산자를 사용해 반복해서 요소를 참조할 수 있음.

																// Find() 함수의 원형
																template<class InputIterator, class T>
																InputIterator Find(InputIterator first, InputIterator last, const T& value);
								- 출력 반복자(output iterator) : 컨테이너의 값을 변경하는데 사용(쓰기 전용)
																 증가 연산자를 사용해 순방향으로만 이동 가능.
																 참조 연산자를 사용해 단 한 번만 요소에 값을 쓸 수 있음.

																 // Copy() 함수의 원형
																 template<class InputIterator, class OutputIterator>
																 OutputIterator Copy(InputIterator first, InputIterator last, OutputIterator result);
								- 순방향 반복자(forward iterator) : 입출력이 모두 가능한 반복자. 다중 패스 알고리즘에 사용 가능
																	증가 연산자를 사용해 순방향으로만 이동 가능.
																	참조 연산자(*)를 사용하여 몇 번이고 반복해서 같은 요소를 참조하거나, 그 값을 변경할 수 있음.(입력 반복자와 출력 반복자의 기능을 모두 포함하고 있음)

																	// Replace() 함수의 원형
																	template<class ForwardIterator, class T>
																	void Replace(ForwardIterator first, ForwardIterator last, const T& target, const T& replacement);
								- 양방향 반복자(bidirectional iterator) : 입출력이 모두 가능한 반복자
																		  증가 연산자(++)를 사용하면 순방향으로, 감소 연산자(--)를 사용하면 역방향으로도 이동할 수 있음.
																		  참조 연산자(*)를 사용하여 몇 번이고 반복해서 같은 요소를 참조하거나, 그 값을 변경할 수 있음.(순방향 반복자의 기능을 모두 포함하고 있음)

																		  // Reverse() 함수의 원형
																		  template<class BidirectionalIterator, class OutputIterator>
																		  OutputIterator Reverse(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);
								- 임의 접근 반복자(random access iterator) : 최상위 레벨의 반복자
																			 임의 접근 반복자는 양방향 반복자의 모든 기능을 포함하고 있으며, 첨자 연산자([])를 통해 임의의 요소에 접근할 수 있음.
																			 증감 연산자를 통해 양방향으로 이동할 수 있으며, 요소의 순서를 결정하기 위해 관계 연산자를 사용할 수 있음.
																			 임의 접근 반복자는 양방향 반복자의 모든 기능과 함께 기존의 일반 포인터가 하는 거의 모든 일을 할 수 있음.

																			 // Sort() 함수의 원형
																			 template<class RandomAccessIterator>
																			 void Sort(RandomAccessIterator first, RandomAccessIterator last);
							반복자 계층 : 필요할 때 검색해서 찾아보셈 ㅡㅡ
							기타 반복자
								iterator 헤더 파일 : 미리 정의된 반복자뿐만 아니라 스트림 반복자, 반복자의 원형 그리고 여러 지원 템플릿을 포함하고 있음
								스트림 반복자 : 반복자 연산을 통해 알고리즘이 입출력 스트림에 보다 쉽게 접근할 수 있도록 해줌.
												이때 STL은 입력과 출력 스트림을 각각 입력과 출력 반복자로 변환하는 방식으로 제공함.
												입력 스트림 반복자는 istream_iterator, 출력 스트림 반복자는 ostream_iterator 클래스 템플릿에서 제공
												사용자는 입출력하고자 하는 데이터의 타입만을 인수로 전달하여 간편하게 사용할 수 있음
												// copy() 함수를 사용하여 vertor 객체의 첫 요소부터 마지막 요소까지를 모두 출력하는 예제
													vector<int> vc = {1, 2, 3, 4, 5};
													copy(vc.begin(), vc.end(), ostream_iterator<int>(cout));
													cout << endl;
													copy(vc.begin(), vc.end(), ostream_iterator<int>(cout, " "));
												// output
													12345
													1 2 3 4 5
								삽입 반복자 : 값을 덮어쓰지 않고, 그 요소의 위치에 새로운 값을 삽입할 수 있게 해줌. 삽입 반복자는 반복자의 복사 연산을 삽입 연산으로 변환해 주는 역할을 함.
											  - insert_iterator : 특정 위치에 삽입. insert(). 모든 컨테이너에서 사용 가능
											  - back_insert_iterator : 해당 컨테이너의 뒤쪽에 삽입. push_back(). 시퀀스 컨테이너(vector, list, deque)
											  - front_insert_iterator : 해당 컨테이너의 앞쪽에 삽입. push_front(). list, deque
													list<int> ls = {10};
													ls.push_back(20); // back_insert_iterator를 사용함.
													ls.push_front(30); // front_insert_iterator를 사용함.
													copy(ls.begin(), ls.end(), ostream_iterator<int>(cout, " ")); // 30 10 20
								역방향 반복자 : 순방향 반복자와는 반대 방향으로 동작하는 반복자
												역방향 반복자의 증가 연산자(++)는 순방향 반복자의 역방향으로 이동하게 됨
												rbegin()과 rend() 멤버 함수를 사용하면 자동으로 reverse_iterator를 반환합니다.
								상수 반복자 : 반복자가 가리키는 값이 변경이 불가능한 반복자
											  반복자가 가리키는 요소를 상수화시킨 것이지 반복자 그 자체를 상수화시킨 것은 아님
											  양방향 상수 반복자라면 앞뒤로 이동하며 다른 요소를 가리키는 것이 가능하며, const_iterator 타입으로 정의됨.
*/											
/* STL 컨테이너
	컨테이너 : 같은 타입의 여러 객체를 저장하는 일종의 집합
			   클래스 템플릿으로, 컨테이너 변수를 선언할 때 컨테이너에 포함할 요소의 타입을 명시할 수 있음
			   컨테이너에는 복사, 생성, 대입이 가능한 타입의 객체만을 저장할 수 있음
			   요소의 추가 및 제거를 포함한 다양한 작업을 도와주는 여러 멤버 함수를 포함하고 있음.
			   컨테이너의 각 요소에는 반복자를 사용하여 접근할 수 있음.
			   - Sequence Container(시퀀스) : 데이터를 선형으로 저장하며, 특별한 제약이나 규칙이 없는 가장 일반적인 컨테이너. vector, deque, list, forwad_list
			   - Associative Container(연관) : 데이터를 일정 규칙에 따라 조직화하여 저장하고 관리하는 컨테이너. set, multiset, map, multimap
			   - Container Adapter : 간결함과 명료성을 위해 인터페이스를 제한한 시퀀스나 연관 컨테이너의 변형으로, 반복자를 지원하지 않으므로 STL 알고리즘에서는 사용할 수 없음. stack, queue, priority_queue
	시퀀스 컨테이너 : 데이터를 선형으로 저장하며, 특별한 제약이나 규칙이 없는 가장 일반적인 컨테이너. 삽입된 요소의 순서가 그대로 유지됨
					  요구사항
						- 모든 요소가 직선 순서대로 배치되어 있어야 함. 첫 번째 요소와 마지막 요소를 제외한 나머지 요소들은 반드시 앞뒤로 인접한 요소를 하나씩 가지고 있어야 함.
						- 반복자가 최소한 순방향 반복자 이상이어야 함. 반복자가 이동할 때 마다 요소들의 순서가 변하지 않음을 보장해 주는 것
						- 시퀀스 컨테이너의 요소들은 명확한 순서를 가지므로, 특정 위치를 참조하는 연산이 가능해야 함.
					  벡터(vector) : 동적 배열의 클래스 템플릿 표현
									 요소가 추가되거나 삭제될 때마다 자동으로 메모리를 재할당하여 크기를 동적으로 변경함
									 vector 헤더 파일에 정의되어 있으며, 임의 접근을 제공하는 가장 간단한 시퀀스 컨테이너임.
										vector<템플릿인수> 객체이름(생성자인수) // 생성자 인수는 벡터 컨테이너의 초기 크기를 전달, 생략하면 빈 벡터를 생성
										- size() : 컨테이너에 저장된 요소의 개수를 반환
										- push_back() : 맨 뒤에 데이터를 추가
										- begin() : 컨테이너의 첫 번째 요소를 가리키는 반복자를 반환
										- end() : 컨테이너의 마지막 요소 바로 다음(past-the-end)를 가리키는 반복자를 반환
					  데큐(deque) : double-ended queue를 의미하며, 양쪽에 끝이 있는 큐(queue).
									컨테이너의 양 끝에서 빠르게 요소를 삽입하거나 삭제할 수 있음
									deque 헤더 파일에 정의되어 있음
									임의 접근과 동적 크기, 전방 삽입과 전방 삭제도 빠르게 수행 가능.
										- push_front() : 맨 앞에 데이터 추가
										- front() : 컨테이너의 첫 번째 요소 반환
										- pop_front() : 첫 번째 요소 삭제
					  순방향 리스트(forward_list) : 단방향 연결 리스트(singly linked list)의 클래스 템플릿 표현
													C++부터 추가됐으며, 모든 요소에서 순방향으로 접근은 가능하나 역방향으로 접근할 수는 없다. - 오직 순방향 반복자만 사용 가능.
													더 적은 메모리를 가지고 간편하게 사용할 수 있는 장점이 있음.
														- remove() : 전달된 값과 같은 값을 가지는 요소를 컨테이너에서 모두 삭제
														- splice_after() : 해당 요소를 원본 순방향 리스트에서 삭제하고, 대상 순방향 리스트의 지정된 위치에 삽입(이동)
					  리스트(list) : 이중 연결 리스트(doubly linked list)의 클래스 템플릿 표현.
									 컨테이너의 모든 요소에서 양방향 접근, 빠른 삽입과 삭제를 할 수 있으나, 임의 접근은 못함.
									 list 헤더 파일에 정의되어 있음
									 요소들의 빠른 삽입과 삭제가 장점.
									 아래 작업을 링크만 재배치하는 것으로 아주 빠르게 수행할 수 있음.
										- swap() : 두 요소의 위치를 서로 바꿈
										- reverse() : 리스트 전체의 위치를 역순으로 변경
										- sort() : 리스트 전체의 요소를 정렬
										- unique() : 같은 값이 인접해 있을 경우, 그 값들을 하나로 단일화
										- merge() : 두 정렬된 리스트를 합병
										- splice() : 두 리스트를 연결하거나, 한 쪽 리스트로 이동
	연관 컨테이너(Associate Container) : 키와 값처럼 관련있는 데이터를 하나의 쌍으로 저장하는 컨테이너.
										 요소들에 대한 빠른 접근을 제공하나, 삽입되는 요소의 위치를 지정할 수 없다.
										 보통 균형 잡힌 이진 탐색 트리(Balanced Binary Search Tree)나 해시 테이블(Hash Table)을 이용하여 구현

										 - set/multiset : 집합 컨테이너는 저장하는 데이터 그 자체를 키로 사용하는 가장 단순한 연관 컨테이너
														  벡터와 달리 오름차순으로 정렬된 위치에 요소를 삽입하므로 검색 속도가 매우 빠름

														  집합에서 키는 유일해야 하므로, 키의 중복을 허용하지 않음
														  멀티집합에서는 키의 중복을 허용함.
														  set 헤더 파일에 정의되어 있음
														  set<템플릿인수> 객체이름;
																int arr[5] = {10, 20, 30, 40, 50}; // 배열 생성 및 초기화
																set<int> st(arr, arr+3); // 배열의 일부 요소를 가지고 셋 컨테이너를 생성함.
																cout << "현재 집합의 모든 요소는 다음과 같습니다." << endl;
																copy(st.begin(), st.end(), ostream_iterator<int>(cout, " ")); // 10, 20, 30
														  - insert() : 컨테이너에 해당 데이터를 추가
														  - erase() : 전달된 값과 같은 값을 가지는 요소를 컨테이너에서 모두 삭제
										 - map/multimap : 맵 컨테이너는 키와 값의 쌍으로 데이터를 관리하는 진정한 연관 컨테이너
														  정렬된 위치에 요소를 삽입하므로 검색 속도가 매우 빠름

														  맵에서 키는 유일해야 하므로, 키의 중복을 허용하지 않음
														  멀티맵에서는 키의 중복을 허용함.
														  map 헤더 파일에 정의되어 있음
														  map<템플릿인수> 객체이름; // 템플릿 인수로는 맵 컨테이너에 저장될 키의 타입과 값의 타입을 전달
																map<string, int> mp;
																mp.insert(pair<string, int>("국어", 80)); // 익명의 pair 객체를 생성하여 추가함.
																mp["수학"] = 100; // 첨자 연산자를 이용하여 추가함.
																cout << "현재 맵의 모든 요소는 다음과 같습니다." << endl;
																map<string, int>::iterator it;
																for(it = mp.begin(); it != mp.end(); it++;)
																	cout << it->first << " : " << it->second << endl;
																// 국어 : 80, 수학 100
	순서가 지정되지 않은 연관 컨테이너 : 기존의 연관 컨테이너는 tree 구조를 기반으로 동작하지만, C++11부터 추가된 이 컨테이너는 hash table을 기반으로 동작.
										 요소의 추가, 삭제 속도가 빨라졌으며, 다양한 검색 알고리즘을 사용할 수 있음.
										 순방향 반복자만을 지원
										 - unordered_set / unordered_multiset / unordered_map / unordered_multimap

	컨테이너 어댑터(Container Adapter) : 기존 컨테이너의 인터페이스를 제한하여 만든 기능이 제한되거나 변형된 컨테이너
										 각각의 기초가 되는 클래스의 인터페이스를 제한하여, 특정 형태의 동작만을 수행하도록 함.
										 반복자를 지원하지 않아 STL 알고리즘에서는 사용 불가능

										 - stack : vector 클래스의 인터페이스를 제한하여, 전형적인 스택 메모리 구조의 인터페이스를 제공.
												   stack 헤더 파일에 정의되어 있음
												   선형 메모리 공간에 데이터를 저장하면서 후입선출의 시멘틱을 따르는 자료 구조
												   가장 나중에 Push된 데이터가 가장 먼저 Pop되는 구조
														- empty() : 스택이 비어 있으면 true를, 비어 있지 않으면 false를 반환
														- size() : 스택 요소의 총 개수를 반환
														- top() : 스택의 제일 상단에 있는(제일 마지막으로 저장된) 요소에 대한 참조를 반환
														- push() : 스택의 제일 상단에 요소를 삽입
														- pop() : 스택의 제일 상단에 있는 요소를 삭제
												   임의 접근과 스택을 순회하는 반복자를 허용하지 않음
										 - queue : deque 클래스의 인터페이스를 제한하여, 전형적인 큐 메모리 구조의 인터페이스를 제공
												   queue 헤더 파일에 정의되어 있음
												   선형 메모리 공간에 데이터를 저장하면서 선입선출의 시멘틱을 따르는 자료 구조
												   가장 먼저 Push된 데이터가 가장 먼저 Pop되는 구조
														- empty() : 큐이 비어 있으면 true를, 비어 있지 않으면 false를 반환
														- size() : 큐 요소의 총 개수를 반환
														- front() : 큐의 맨 앞에 있는(제일 먼저 저장된) 요소에 대한 참조를 반환
														- back() : 큐의 맨 뒤에 있는(제일 나중에 저장된) 요소에 대한 참조를 반환
														- push() : 스택의 맨 뒤에 요소를 삽입
														- pop() : 스택의 맨 앞의 요소를 삭제
										 - priority_queue : 큐의 맨 앞 요소로 가장 큰 값을 지닌 요소가 위치.
															vector 클래스를 기반으로 하나, 사용할 수 있는 멤버 함수는 큐 컨테이너와 같다.
															queue 헤더 파일에 정의되어 있음
															우선순위 큐의 요소는 언제나 값의 내림차순으로 정렬되게 함
*/
/* STL 알고리즘
	함수 객체(Function Object) : 호출 연산자(())와 함께 사용할 수 있는 객체로, 펑크터(functor)라고도 불림.
								 우선 타입을 선언하고, 해당 클래스에서 호출 연산자를 오버로딩하여 구현하게 됨.
								 직접적인 함수 호출과 비교하여 함수 객체를 사용하면
									함수 객체는 상태(state)를 포함할 수 있고,
									함수 객체는 타입이므로, 템플릿 인수로 사용할 수 있는 장점을 가짐.
								 미리 정의된 함수 객체 : 함수를 매개변수로 전달받는 STL 함수를 지원하기 위해 제공됨
									- 함수 포인터
									- 함수 객체
									- 람다 표현식
														 functional 헤더 파일에 정의되어 있음
														 	 plus : +
														 	 minus : -
														 	 multiplies : *
														 	 divides : /
															 modulus : %
															 negate : -
															 equal_to : ==
															 not_equal_to : !=
															 greater : >
															 greater_equal : >=
															 less : <
															 less_equal : <=
															 logical_and : &&
															 logical_or : ||
															 logical_not : !

 															 // 함수 객체를 사용하여 일반적인 산술 연산 및 관계 연산을 구현한 예제
																 plus<int> add;
																 equal_to<int> comp;
																 greater_equal<int> ge; 

																 cout << add(7, 3) << endl; // 10
																 cout << comp(7, 3) << endl; // 0(다르다)
																 cout << ge(7, 3); // 1(7이 더 크다)
															 함수 객체는 일반적으로 위와 같이 사용하지는 않으며, 보통 함수의 인수로 전달될 때 사용된다
															 // greater와 less 함수 객체를 각각 sort() 함수의 인수로 전달하여 사용하는 예제

																 vector<int> vc = {20, 40, 10, 30}; // vector 객체의 선언 및 초기화
																 sort(vc.begin(), vc.end(), greater<int>());
																 copy(vc.begin(), vc.end(), ostream_iterator<int>(cout, " ")); // 40 30 20 10
																 cout << endl;

																 sort(vc.begin(), vc.end(), less<int>());
																 copy(vc.begin(), vc.end(), ostream_iterator<int>(cout, " ")); // 10 20 30 40
								 
	알고리즘
		STL 알고리즘 함수 : 일반적인 알고리즘에 대한 효율적인 구현 제공
							반드시 필요한 기능만을 포함하나, 동작하는데 필요한 모든 기능을 가지고 있지는 않음
							따라서 STL 컨테이너는 알고리즘을 제공하는 많은 전역 함수와 함께 사용해야만 제 기능을 발휘할 수 있음 - 이렇게 제공되는 STL 알고리즘 함수는 반복자를 통해 임의의 컨테이너에 같은 방법으로 적용됨
							대부분의 알고리즘 함수는 algorithm 헤더 파일과 numeric 헤더 파일에 정의되어 있음

							- 읽기 알고리즘(algorithm) : 컨테이너를 변경하지 않으며, 지정된 범위에서 특정 데이터를 읽기만 하는 함수
															find() : 두 개의 입력 반복자로 지정된 범위에서 특정 값을 가지는 첫 번째 요소를 가리키는 입력 반복자를 반환
															for_each() : 두 개의 입력 반복자로 지정된 범위의 모든 요소를 함수 객체에 대입한 후, 대입한 함수 객체를 반환
							- 변경 알고리즘(algorithm) : 컨테이너를 변경하지 않으며, 지정된 범위에서 요소의 값만을 변경할 수 있는 함수
															copy() : 두 개의 입력 반복자로 지정된 범위의 모든 요소를 출력 반복자가 가리키는 위치에 복사 // 출력이구나
															swap() : 두 개의 참조가 가리키는 위치의 값을 서로 교환
															transform() : 두 개의 입력 반복자로 지정된 범위의 모든 요소를 함수 객체에 대입한 후, 출력 반복자가 가리키는 위치에 복사
							- 정렬 알고리즘(algorithm) : 컨테이너의 지정된 범위의 요소들이 정렬되도록 컨테이너를 변경하는 함수
														 모든 정렬 알고리즘 함수는 올바른 정렬을 위해 임의 접근 반복자를 사용하므로, 임의 접근이 가능한 컨테이너만이 사용할 수 있음
															sort() : 두 개의 임의 접근 반복자로 지정된 범위의 모든 요소를 서로 비교하여 오름차순으로 정렬
															stable_sort() : 두 개의 임의 접근 반복자로 지정된 범위의 모든 요소를 서로 비교하여, 값이 서로 같은 요소들의 상대적인 순서는 유지하면서 오름차순으로 정렬
															binary_search() : sort() 함수를 사용하여 오름차순으로 정렬한 후에, 전달된 값과 같은 값이 있으면 true를 반환하고 없으면 false를 반환
							- 수치 알고리즘(numeric) : numeric 헤더 파일에 정의되어 있음
															accumulate() : 두 개의 입력 반복자로 지정된 범위의 모든 요소의 합을 반환
*/
/* 입력과 출력
	C++ 컴파일러는 iostream과 fstream 헤더 파일에 정의되어 있는 클래스 라이브러리를 제공.
	스트림(stream) : C++ 프로그램은 파일이나 콘솔의 입출력을 직접 다루지 않고, stream이라는 흐름을 통해 다룸.
					 실제의 입력이나 출력이 표현된 데이터의 이상화된 흐름. 운영체제에 의해 생성되는 가상의 연결 고리를 의미하며, 중간 매개자 역할을 함
	버퍼(buffer) : 임시 메모리 공간. 입력과 출력을 좀 더 효율적으로 처리할 수 있게 됨.

	File : 의미 있는 정보를 담고 있으며, 이름을 가지고 있는 저장 장치상의 논리적인 단위. C++에서는 파일을 바이트별로 따로 읽을 수 있는 연속적인 바이트의 집합으로 취급
		   Binary file과 text file로 나누어 다룸.

	C++ 파일 입출력 클래스 : fstream (입력_ifstream, 출력_ofstream)
	파일의 입출력
		1. 스트림을 관리하기 위한 ifstream(또는 ofstream) 객체를 생성
		2. 특정 파일과의 연결
		3. cin 객체나 cout 객체와 같은 방법으로 (fin, fout) 객체를 사용하여 입출력 수행
		4. 모든 작업이 끝나면 파일과의 연결 종료
			ifstream ifs;            // ifs라는 ifstream 객체를 생성함.
			ifs.open("example.txt"); // ifs를 example.txt와 연결함. || ifstream ifs("example.txt"); // ifs라는 ifstream 객체를 생성하고, example.txt와 연결함. <- 두 줄의 한 줄화
			char ch, buf[20];
			string str;
			ifs >> ch;            // example.txt 파일에서 한 문자를 읽어 변수 ch에 저장함.
			ifs.getline(buf, 20); // example.txt 파일에서 한 행을 읽어 배열 buf에 저장함.
			getline(ifs, str);    // example.txt 파일에서 한 행을 읽어 문자열 객체인 str에 저장함.
			ifs.close(); // 파일과의 연결을 닫음.

	스트림의 상태 검사 : ios_base 클래스의 멤버 함수를 상속받음
							과거) if (ifs.fail()) { ... }  // 파일을 여는데 실패한 경우
							      if (!ifs.good()) { ... } // 파일을 여는데 실패한 경우
								  if (!ifs) { ... }        // 파일을 여는데 실패한 경우
							현재) if (!ifs.is_open()) { ... } // 파일을 여는데 실패한 경우
	
	파일 모드 : 파일 모드 상수는 ifstream(또는 ofstream) 객체를 파일의 이름으로 초기화하거나, open() 멤버 함수를 통해 스트림에 파일을 연결할 때 파일 모드를 지정하기 위한 두 번째 매개변수로 사용된다
					// ifs라는 ifstream 객체를 생성하고, example.txt와 읽기 모드로 연결함.
					ifstream ifs("example.txt", ios_base::in);
				기본적으로 ifstream의 생성자와 open() 멤버 함수는 파일 모드의 디폴트 인수로 ios_base::in을 제공하며, ofstream의 생성자와 open() 멤버 함수는 파일 모드의 디폴트 인수로 ios_base::out | ios_base::trunc을 제공한다.

					- ios_base::in : 파일을 읽기 전용으로 염
					- ios_base::out : 파일을 쓰기 전용으로 염
					- ios_base::ate : 파일을 열 때 파일의 끝으로 파일 포인터를 이동시킴
					- ios_base::app : 해당 파일의 맨 끝에서부터 데이터를 추가함
					- ios_base::trunc : 파일이 있으면, 해당 파일의 모든 데이터를 지우고 염
					- ios_base::binary : 파일을 바이너리 모드로 염

				파일 모드 상수는 조합 가능
					파일 모드 상수 / C언어 파일 모드 / 설명
					ios_base::out | ios_base::trunc / "w" / 쓰기 전용, 파일이 없으면 새 파일을 만들고, 파일이 있으면 해당 파일의 모든 데이터를 지우고 염
					ios_base::out | ios_base::app / "a" / 쓰기 전용, 파일이 없으면 새 파일을 만들고, 파일이 있으면 해당 파일의 맨 끝에서부터 데이터를 추가
					ios_base::in | ios_base::out / "r+" / 파일을 읽고 쓰는 것이 둘 다 가능한 모드로 염
					ios_base::in | ios_base::out | ios_base::trunc / "w+" / 파일을 읽고 쓰는 것이 둘 다 가능한 모드로 열고, 파일이 없으면 새 파일을 만들고, 파일이 있으면 해당 파일의 모든 데이터를 지우고 개방
*/
/* 예외 처리
	try 문 : 예외가 발생할 가능성이 있는 코드 블록
	throw 문 : try 문에서 발생한 오류에 대한 정보를 전달
	catch 절 : 발생한 예외에 대해 예외 핸들러가 처리할 내용을 담은 코드 블록

	스택 풀기(Stack unwinding) : 예외를 처리하는 영역을 찾지 못해서 해당 예외가 호출된 영역의 상위 함수로 예외가 계속해서 전달되는 현상

	예외 클래스 : 예외 클래스는 오류 코드값을 가지는 멤버 변수 및 오류 코드를 검사하거나 오류 메시지를 출력하는 멤버 함수 등 오류에 대한 모든 처리가 가능하도록 다양한 멤버를 포함하고 있음.
				  상속할 수 있고, 다형성도 성립. 생성자와 연산자에서도 예외 처리 기능을 사용할 수 있음.
	Exception 클래스 : 시스템에 따라 하나의 문자열 포인터를 반환하는 what()이라는 가상 멤버 함수를 제공함.
					   exception 클래스로부터 파생된 클래스 내에서 재정의할 수 있음.
					   별다른 일을 하지는 않지만, 파생 클래스에서는 원하는 문자열을 출력할 수 있도록 재정의할 수 있음.
	표준 예외 클래스 : logic_error / runtime_error
					   stdexcept 헤더 파일은 다른 표준 예외 클래스의 기초 클래스가 되는 두 개의 클래스를 정의함.
							- logic_error : 일반적인 논리에 관한 오류들을 처리할 수 있음
							- runtime_error : 프로그램이 실행하는 동안 발생할 수 있는 다양한 오류들을 처리할 수 있음
	처리되지 않은 예외 : C++ 프로그램은 발생한 예외를 처리할 catch 절을 찾을 수 없을 때, 미리 정의된 terminate() 함수를 호출함
						 terminate() 함수는 기본적으로 abort() 함수를 호출하여 프로그램을 강제로 종료시킴
						 set_terminate() 함수를 사용하면 이러한 terminate() 함수의 기본 동작을 변경할 수 있다.
							void MyErrorHandler()
							{
							    cout << "처리되지 않은 예외가 발생했습니다." << endl;
								exit(-1);
							}
							int main(void)
							{
								set_terminate(MyErrorHandler);
								try { throw 1; }
								catch (char* const ex) { // 이 catch 절은 정수형 예외를 처리할 수 없음. }
								...
	예외 처리 시 주의 사항 : 예외가 발생하여 실행되고 있던 프로그램이 중지되는 현상은 매우 심각한 상황으로, 발생한 예외를 처리하는 노력은 매우 중요하다.
							 하지만 이러한 예외 처리에는 개발자의 많은 노력이 필요하며, C++의 예외 처리 기능을 사용하면 프로그램의 크기가 커지고 실행 속도가 크게 떨어지게 된다.
							 따라서 모주건 발생할 수 있는 모든 예외를 다 처리하는 것이 아니라, 적당한 타협점을 찾는 게 중요하다.
*/