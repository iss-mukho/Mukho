/*
... iss Crew
... Made by Mukho
... 2020-06-19 FRI
... Practice for C++
*/
#include <iostream>
using namespace std;

int main()
{
	// 배열
	int arr[5] = { 69,74,104,204,892 };

	// 기본 방법
	for (int i = 0; i < 5; i++)
		cout << arr[i] << ' ';
	cout << endl;

	// 범위 기반의 for문(신세카이)
	for (int i : arr)
		cout << i << ' ';

	return 0;
}

/*	C++
		기존의 C언어에 여러 가지 기능을 추가함.
		절차 지향적 언어의 특징 + 클래스를 사용하는 객체 지향적 언어 + 템플릿으로 대변되는 일반화 프로그래밍 방식의 언어
		Object-Oriented Programming
		namespace : 이름이 기억되는 영역. 프로그램을 작성할 때 발생하는 이름에 대한 충돌을 방지해 주는 방법을 제공.
		using namespace std; // std라는 네임스페이스에 속한 정의들은 네임스페이스 이름을 붙이지 않아도 사용할 수 있음.

		iostream(C++ 표준 입출력 클래스) : cout(출력), cin(입력)	// printf()나 scanf()로도 입출력 수행 가능
											- 삽입 연산자(<<)와 추출 연산자(>>)가 데이터의 흐름을 나타내므로 더 직관적.
											- 입출력 데이터의 타입을 자동으로 변환시켜주므로 편리하고 안전함.


		포인터 리터럴 상수 : Null Pointer(아무것도 가리키고 있지 않은 포인터)
							 C++11부터는 nullptr 키워드를 제공해 0으로 초기화된 null pointer보다 더 제대로 null pointer를 표현할 수 있음.
		auto 키워드 : C++11부터는 변수의 초기화 값에 맞춰 변수의 타입을 추론할 수 있음.
					  변수를 초기화할 때 특정 타입을 명시하는 대신에, auto 키워드를 사용해 초깃값에 맞춰 타입이 자동으로 선언되도록 설정할 수 있음.
		명시적 타입 변환 예시
			int num1 = 1;
			int num2 = 4;
			double result1 = (double) num1 / num2;
			double result2 = double (num1) / num2; // C++에서만 사용한 방식

		C++ 연산자
			범위 지정 연산자(Scope Resolution Operator) : 범위 지정 연산자(::)는 여러 범위에서 사용된 식별자를 식별하고 구분하는데 사용. 식별자에는 변수, 함수 또는 열거체가 올 수 있음.
														  범위 지정 연산자를 변수의 이름 앞에 붙이면 해당 변수는 전역으로 사용하라는 의미.
														  클래스에 사용하면 네임스페이스 멤버를 식별하거나, 클래스의 정적 멤버를 호출할 수 있음.
															  1. ::식별자
															  2. 클래스이름::식별자
														  	  3. 네임스페이스::식별자
														      4. 열거체::식별자
			멤버 포인터 연산자(Pointer-to-Member Operator) : 왼쪽의 피연산자가 클래스 타입의 객체인 경우 - .* (클래스타입의객체.*멤버이름)
															 왼쪽의 피연산자가 클래스 타입의 객체를 가리키는 포인터인 경우 : ->* (클래스타입객체의포인터->*멤버이름)
			typeid 연산자 : 객체의 타입에 관한 정보를 확인할 수 있음. 템플릿에서 템플릿 매개변수의 타입을 결정할 때도 사용.

		범위 기반의 for 문(C++11부터 추가됨) : 표현식 안에 포함되어 있는 모든 값에 대해 한 번씩 루프를 실행함.
											   배열을 자동으로 인식, 컨테이너 클래스에서 많이 사용됨.
		배열의 길이 자동 설정 : ex) int arr[] = { 69,74,892 };
		C++11에서의 배열 초기화
			- 배열을 초기화할 때에 대입 연산자(=)를 사용하지 않아도 됨.
			- 값을 명시하지 않고 괄호( {} )만을 사용하여 초기화하면, 모든 배열 요소를 0으로 초기화할 수 있음.
			- 초기화 리스트를 사용하여 배열을 초기화할 경우에는 Narrowing cast를 할 수 없다.
			- array Template Class가 추가됨.

			Narrowing Cast : 초기화를 통해 발생하는 암시적인 데이터의 손실 (int var = 3.14; // narrowing cast) -> (int var = {3.14}; // 초기화 리스트를 통한 narrowing cast는 허용하지 않으므로, 경고를 발생시킴.)


		C++에서는 배열의 이름을 포인터처럼 사용할 수 있을 뿐만 아니라, 포인터를 배열의 이름처럼 사용할 수도 있다.
			= 배열의 이름이 주소로 해석되며, 해당 배열의 첫 번째 요소의 주소와 같다.
				int arr[3] = {10, 20, 30}; // 배열 선언
				int* ptr_arr = arr; // 포인터에 배열의 이름을 대입함.

				cout << "배열의 이름을 이용하여 배열 요소에 접근 : " << arr[0] << ", " << arr[1] << ", " << arr[2] << endl;
				cout << "배열의 이름으로 포인터 연산을 해 배열 요소에 접근 : " << *(arr+0) << ", " << *(arr+1) << ", " << *(arr+2) << endl;
				cout << " 포인터를 이용하여 배열 요소에 접근 : " << ptr_arr[0] << ", " << ptr_arr[1] << ", " << ptr_arr[2] << endl;
				cout << "배열의 이름을 이용한 배열의 크기 계산 : " << sizeof(arr) << endl;
				cout << " 포인터를 이용한 배열의 크기 계산 : " << sizeof(ptr_arr);

				-> 배열의 이름을 이용하여 배열 요소에 접근 : 10, 20, 30
					포인터를 이용하여 배열 요소에 접근 : 10, 20, 30
				   배열의 이름으로 포인터 연산을 해 배열 요소에 접근 : 10, 20, 30
				   배열의 이름을 이용한 배열의 크기 계산 : 12
					포인터를 이용한 배열의 크기 계산 : 8

		메모리의 동적할당 및 해제 : new, delete
			new 연산자 : int *arr = new int;
						 *arr = 100;
						 int *arr = new int [20]; // 배열
							자유 기억 공간이라고 불리는 메모리 공간에 객체를 위한 메모리를 할당 받음.
							new 연산자를 통해 할당받은 메모리는 따로 이름이 없으므로 해당 포인터로만 접근할 수 있게 됨.
			delete 연산자 : delete arr;
*/