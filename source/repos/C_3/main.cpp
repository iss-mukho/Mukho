/*
... iss Crew
... Made by Mukho
... 2020-06-18 THU
... Practice for C
*/

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main()
{

	return 0;
}

/* 구조체(Structure)
	- 사용자가 C언어의 기본 타입을 가지고 새롭게 정의할 수 있는 사용자 정의 타입.
	- 다양한 타입의 변수 집합을 하나의 타입으로 나타낸 것

	struct 구조체이름
	{
		Type1 MemVarName1;
		Type2 MemVarName2;
	};
	struct 구조체이름 test_structure; : 선언

	typedef : 이미 존재하는 타입에 새로운 이름을 붙일 때.
	typedef struct 구조체이름 구조체의 새로운이름;

	구조체 변수의 초기화
	my_book = {.title = "HTML과 CSS". .author = "홍길동", .price = 28000}; // 초기화하지 않은 멤버 변수는 0으로 초기화됨.
	my_book = {"HTML과 CSS", "홍길동", 28000};

	구조체 배열 선언
	struct book text_book[3] = 
	{
		{"국어", "홍길동", 15000}, // text_book[0].title = "국어"
		{"영어", "이순신", 18000},
		{"수학1", "강감찬", 10000}
	};

	구조체를 가리키는 포인터
	struct book* ptr_my_book; // * 또는 ->로. 구조체 포인터를 이용해 구조체의 멤버에 접근
		(*ptr_my_book).author // ptr_my_book -> author

	함수를 호출할 때 전달되는 인수나, 함수가 종료될 때 반환되는 반환값으로 구조체를 사용할 수 있다. / 구조체를 가리키는 포인터나 구조체의 한 멤버 변수만을 사용할 수도 있다.
	-> 주소만 전달해서 처리속도는 빠르나, 호출된 함수에서 원본 구조체에 직접 접근하므로 원본 데이터의 보호 측면에서는 위험.
*/

/*
공용체(Union) : 모든 멤버 변수가 하나의 메모리 공간을 공유. 크기가 가장 큰 멤버 변수의 크기로 메모리를 할당받음.
열거체(Enumerated Types) : 새로운 타입을 선언하면서, 동시에 해당 타입이 가질 수 있는 정수형 상숫값도 같이 명시.

콘솔 입출력
	버퍼(Buffer) : 표준 입출력 함수(printf, scanf, puts)를 사용할 때는 버퍼라는 임시 메모리 공간을 사용하게 된다.
		(키보드의 입력이 있을 때 마다 한 문자씩 버퍼로 전송함 -> 버퍼가 가득 차거나, 개행 문자가 나타나면 버퍼의 내용을 한 번에 전송함)
		- 문자를 묶어서 한 번에 전달하므로, 전송 시간이 적게 걸려 성능이 향상됨, 문자를 잘못 입력했을 경우 수정 할 수 있다.
		- 빠른 반응이 요구되는 게임과 같은 프로그램에서는 키를 누르는 즉시 바로 전달되어야 함 -> 버퍼 사용 X
	버퍼링 방식
		- 완전 버퍼링(Fullyl Buffered) : 버퍼가 가득 차면 버퍼 안의 내용을 목적지로 보내는 방식. 보통 파일 입출력에서 사용
		- 라인 버퍼링(Line- Bufferd) : 입력된 문자 중 개행 문자가 나타날 때마다 버퍼 안의 내용을 목적지로 보내는 방식. 보통 키보드 입력에서 사용
	fflush() : int fflush(FILE *stream); 인수로 전달된 스트림에 연결된 버퍼를 비워줌. 비우는데 성공하면 0, 실패하면 eof를 반환함.
		ex) fflush(stdin) : 표준 입력 스트림의 입력 버퍼를 비움
		getchar() 함수를 이용하면 이름을 입력받을 때 마지막으로 입력한(Enter) 키를 입력버퍼에서 비워줌.

파일 입출력
	File : 의미 있는 정보를 담고 있으며, 이름을 가지고 있는 저장 장치상의 논리적인 단위.
		   바이트별로 따로 읽을 수 있는 연속적인 바이트의 집합.
		   - Binary File : 데이터의 저장되 처리를 목적으로 0과 1의 이진 형식으로 인코딩된 파일. 프로그램이 이 파일의 데이터를 읽거나 쓸 때는 데이터의 어떠한 변환도 일어나지 않음.
		   - Text File : 사람이 알아볼 수 있는 문자열로 이루어진 파일. 프로그램이 이 파일의 데이터를 읽거나 쓸 때는 포맷 형식에 따라 데이터의 변환이 일어남.
		   파일과의 연결을 위한 스트림은 사용자가 직접 생성하고 소멸시켜야 함.
		   1) 파일과의 스트림 생성
		   2) FILE 구조체 변수의 포인터를 이용한 작업 진행
		   3) 파일과의 스트림 종결
		   
		   fopen() : FILE *fopen(const char * restrict filename, const char * restrict mode);. (열고자 하는 파일의 이름과 그 경로를 가지고 있는 문자열, 파일을 여는데 사용할 모드_사용용도/어떤 형식으로 입출력할 것인가)
				r(읽기 전용), w(쓰기 전용), a(추가 모드) / t(해당 파일의 데이터를 텍스트 파일로), b(해당 파일의 데이터를 바이너리 파일로), x(열고자 하는 파일이 이미 존재하면 파일 개방에 실패함), +(파일을 읽을 수도 있고 쓸 수도 있는 모드)
				- 못열면 NULL 반환
				- FILE 구조체 변수의 포인터는 해당 파일이 사용하는 버퍼 정보를 비롯한 파일에 관한 정보가 들어있는 데이터를 가리킴. 따라서 모든 파일 입출력 함수는 FILE 구조체 변수의 포인터를 인수로 전달받아 해당 파일에 접근함.
		   fclose() : int fclose(FILE *stream);. 인수로 닫고자 하는 파일을 가리키는 FILE 구조체 변수의 포인터를 전달받음. 닫는데 성공하면 0을, 실패하면 eof를 반환.

		   파일 입출력 함수
		   1. fgetc() 함수 : 지정된 스트림으로부터 하나의 문자를 읽어 들임
		   2. fputc() 함수 : 지정된 스트림에 문자 하나를 출력(저장)함
				int main(void){
					char ch;
					FILE* ptr_file = fopen("text_readonly.txt", "r"); // "C언어 파일 입출력" 문자열이 저장된 파일
					...
					if (ptr_file != NULL)
						while (EOF != (ch = fgetc(ptr_file))) // fgetc() 함수를 사용하여 파일로부터 문자 한 개를 읽어들임.
							fputc(ch, stdout);               // fputc() 함수를 사용하여 모니터에 문자 한 개를 출력함.
					...
				}
		   3. fgets() 함수 : 지정된 스트림으로부터 문자열을 읽어 들임
		   4. fputs() 함수 : 지정된 스트림에 문자열을 출력(저장)함
		   5. fscanf() 함수 : 지정된 스트림으로부터 다양한 서식 변환 문자를 이용하여 문자열을 읽어 들임
		   6. fprintf() 함수 : 지정된 스트림에 다양한 서식 변환 문자를 이용하여 문자열을 출력(저장)함
*/

/*
선행처리기
	선행처리(preprocess) : 실행 파일을 생성하는 과정에서 소스 파일 내에 존재하는 선행처리 지시문을 처리하는 작업.
						   코드를 생성하는 것이 아니라, 컴파일러가 컴파일하기 좋도록 소스를 재구성해 주는 역할.
						   - 선행처리문은 선행처리 문자(#)로 시작한다.
						   - 코드 내에서 하나의 라인을 모두 차지하며, 선행처리문 뒤에 C언어 코드를 추가하여 같이 사용할 수 없다.
						   - 다른 C언어의 명령문과는 달리 맨 뒤에 세미콜론(;)을 붙이지 않는다.
						   - 소스 파일 어디에나 위치할 수 있지만, 선행처리문이 위치한 곳에서부터 파일의 끝까지만 영향을 미친다.

						   - #include : 함수나 상수가 포함된 외부 파일을 현재 파일에 포함할 때
						   - #define : 함수나 상수를 단순화해주는 매크로를 정의할 때
										#define PI 3.14
										매크로 함수 : #define 선행처리 지시문에 인수로 함수의 정의를 전달함으로써, 함수처럼 동작하는 매크로를 만들 수 있다.(단순 치환이지, 일반 함수와 완전히 똑같은 방식으로 동작하지는 않음)
											#define SUB(X,Y) X-Y
											#define PRT(X) printf("계산 결과는 %d입니다.\n", X)
											-매크로 함수가 일반 함수와 같이 동작하기 위해서는..
												1. 매크로 함수의 전체를 괄호(())로 감싸야 함
												2. 매크로 함수의 인수들도 각각 괄호로 감싸야 함
												3. 매크로 함수를 호출할 때에는 증감 연산자(++, --)나 복합 대입 연산자 등은 사용하지 않는 것이 좋음
											- 단순 치환만을 해주므로 인수의 타입을 신경 쓰지 않음.
											- 여러 개의 명령문을 동시에 포함할 수 있음.
											- 함수 호출에 의한 성능 저하가 일어나지 않아 프로그램의 실행속도가 향상됨.
											- 원하는 결과를 얻는 정확한 매크로 함수의 구현이 어려워 디버깅이 어려움
											- 매크로 함수의 크기가 증가하면 증가할수록 사용되는 괄호가 많아져 가독성이 떨어짐.
											-> 따라서 간단한 함수를 대체하는 데 사용하자.
						   - #undef : #define 지시자로 이미 정의된 매크로를 삭재할 때
						   - #line : __LINE__ 매크로와 __FILE__ 매크로를 재정의할 때. 주로 컴파일러가 오류 메시지를 위해 사용
						   - #error : 지정한 오류 메시지를 출력하고, 컴파일 과정을 중단하고자 할 때. 디버깅에 사용
						   - #pragma : 프로그램의 이식성을 위해 운영체제별로 달라지는 지시사항을 컴파일러에 전달할 때
						   - #if, #ifdef, #ifndef, #elif, #else, #endif : 조건부 컴파일 지시자

						   - #, ##연산자 : 선행처리기 연산자.
						   - # :매크로 함수의 대체 리스트 안의 인수 앞에 사용하여, 토큰을 문자열로 변환시켜줌
								해당 토큰은 실인수로 치환되면서 양쪽에 위치한 큰따옴표("")를 포함해 그대로 문자열 상수로 변환됨
								# 연산자를 사용하면 문자열 안에 매크로 함수로 전달된 인수를 포함시킬 수 있음
						   - ## : 두 개의 토큰을 하나의 토큰으로 결합해 주는 선행처리기 연산자
								  함수 같은 매크로뿐만 아니라 객체 같은 매크로의 대체 리스트에도 사용할 수 있음
								  이 연산자를 사용하면 변수나 함수의 이름을 프로그램의 런타임에 정의할 수 있음
미리 정의된 매크로 : 사용자가 재정의할 수 없음.
	__DATE__ : 선행처리가 수행된 날짜를 "Mmm dd yyyy"형식으로 나타낸 문자열
	__TIME__ : 선행처리가 수행된 시간을 "hh:mm:ss"형식으로 나타낸 문자열
	__FILE__ : 현재 소스 파일의 이름을 나타내는 문자열
	__LINE__ : 현재 소스 파일에서 처리중인 라인 번호를 나타내는 문자열
	__STDC__ : 컴파일러가 C언어 표준을 따르면 1로 설정함.
	__STDC_HOSTED__ : 호스트 환경이 아니면 0, 호스트 환경이면 1로 설정함.
*/

/*
Header File : 표준 함수의 원형 및 표준 함수와 관련된 다양한 정보를 가지고 있는 파일. .h
	표준 헤더 파일 : 표준 함수의 원형, 매크로 상수, 사용자 정의 타입(구조체, 공용체) 정의, 매크로 함수의 정의
	사용자 헤더 파일
분할 컴파일
	모듈 : 프로그램을 구성하는 구성 요소, 관련된 데이터와 함수를 하나로 묶은 단위.
		   함수의 기능별로 따로 모듈을 구성
	분할 컴파일 : 하나의 실행 파일을 만들기 위해서 소스 파일을 여러 개로 나누어 개발하는 방식
				  최종적인 실행 파일의 생성을 위해서 접근하는 변수나 호출하는 함수가 어디에 있는지 서로 연결해주는 작업을 링크(link)라고 함
	extern : 외부 파일에서 선ㅇ언된 전역 변수를 참조하기 위해 파일 내에서 extern 키워드를 사용해 다시 한 번 변수를 선언해야 함
	static : 분할 컴파일 방식에서 변수의 접근 영역을 해당 파일로만 한정시키고자 할 때는 static 키워드를 사용하여 선언하면 됨.(전역 변수화)
조건부 컴파일(Conditional Compile) : 지정한 조건에 따라 코드의 일정 부분을 컴파일할지 안 할지 지정할 수 있음.
	#if
		#if 조건식1
			컴파일할 명령문1
		#elif 조건식2
			컴파일할 명령문2
		#else
			컴파일할 명령문3
		#endif
	#ifdef : 중복 선언의 가능성을 없앰.(if defined)
	#ifndef : (if not defined) #ifndef 지시자 다음에 나오는 매크로 이름과 같은 이름의 매크로가 앞서 정의되어 있지; 않으면 컴파일할 명령문1이 컴파일될 것

바이트 저장 순서(byte order)
	빅 엔디안(big endian) : 낮은 주소에 데이터의 높은 바이트(MSB, Most Significant Bit)부터 저장하는 방식. 메모리에 저장된 순서 그대로 읽을 수 있으며, 이해하기 쉽다. RISC CPU 계열. 데이터의 각 바이트를 배열처럼 취급하거나 네트워크를 통해 데이터를 전송할 때 사용.
	리틀 엔디안(little endian) : 낮은 주소에 데이터의 낮은 바이트(LSB, Least Significant Bit)부터 저장하는 방식. 인텔CPU 계열. 믈리적으로 데이터를 조작하거나 산술 연산을 수행할 때 효율적.
*/

/* Bitwise Operation
	비트 단위 연산을 통해 사용되는 메모리 공간을 줄이거나, 성능의 향상을 기대할 수 있다.
	~ bit Not
	& bit And
	| bit Or
	^ bit Xor : 서로 다르면 1
	<< Left Shift(*2)
	>> Right Shift(/2). 현재 대부분의 시스템에서는 최상위 부호 비트(MSB)를시프트 연산의 대상에서 제외하고 있다.

	음수의 표현
		부호 비트와 절댓값 방법 : 최상위 1비트로 부호를 표현하고, 나머지 비트로 해당 정수의 절댓값을 표현하는 방법.
								  표현할 수 있는 절댓값의 범위가 절반으로 줄어드나, 음수를 표현할 수 있어 총 표현할 수 있는 크기는 거의 비슷하다. +0과 -0이 따로 존재.
		1의 보수법 : 해당 양수의 모든 비트를 반전하여 음수를 표현. 음수를 비트 NOT 연산만으로 표현할 수 있어 연산이 간단함. +0과 -0이 따로 존재.
		2의 보수법 : 해당 양수의 모든 비트를 반전한 1의 보수에 1을 더하여 음수를 표현하는 방법. +0과 -0이 따로 존재하는 문제점을 해결하기 위해 고안.
					 현재 대부분의 시스템에서는 모두 2의 보수법으로 음수를 표현하고 있음
						이 방법을 사용하면 -0은 2의 보수를 구하는 과정에서 최상위 비트를 초과한 오버플로우가 발생하여 +0이 되므로, 2의 보수법에서는 단 하나의 0만이 존재하게 된다.

	실수의 표현
		고정 소수점(fixed point) 방식 : 소수부의 자릿수를 미리 정해 놓고, 고정된 자릿수로 소수를 표현. 표현할 수 있는 범위가 매우 적다.
		부동 소수점(floating point) 방식 : 하나의 실수를 가수부위 지수부로 나누어 표현. ±(1.가수부)×2^지수부-127. 현재 대부분의 시스템에서 부동 소수점 방식으로 실수를 표현함.
		IEEE 부동 소수점 방식 : 현재 사용되고 있는 부동 소수점 방식은 대부분 IEEE 754 표준을 따르고 있음.

		부동 소수점 방식을 사용하면 고정 소수점 방식보다 훨씬 더 많은 범위까지 표현할 수 있으나, 공식에 의해 항상 오차가 존재한다.
			표현할 수 있는 범위는 늘어나지만, 10진수를 정확하게 표현할 수는 없다. 따라서 컴퓨터에서 실수를 표현하는 방식은 정확한 표현이 아닌 언제나 근사치를 표현할 뿐임을 명심해야 한다.
*/